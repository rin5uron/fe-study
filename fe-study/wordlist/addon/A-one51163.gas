/**
 * A-one 51163（30面）単語カード印刷用ドキュメント生成スクリプト
 * 印刷可能領域を最大活用して用紙の枠にピッタリ合わせます
 *
 * ポリシー：
 *  - シートの文字＋書式（太字／斜体／下線／取消線／色／サイズ／フォント／リンク）を
 *    できるだけそのまま Docs の表セルへコピーする
 *  - Docs 側ではページサイズ・余白・表（枠）だけ設定。段落整形は一切しない
 *
 * 注意：
 *  - DocumentApp.create() を使うため @OnlyCurrentDoc は付けない
 *  - 初回実行時に Docs / Drive へのアクセス承認が必要

 **【重要】レイアウトの微調整について**
- Googleドキュメントの最小余白制限（12.7mm）を考慮して、印刷可能領域を最大活用します。
- カードサイズは印刷可能領域（184.6×271.6mm）を30面で分割して自動計算されます。
- 実際の印刷時にA-one 51163用紙の枠にピッタリ合うよう最適化されています。
 */

// ===================== 設定（必要に応じて微調整） =====================
const CONFIG = {
  PAGE_WIDTH: 210,    // A4 幅 (mm)
  PAGE_HEIGHT: 297,   // A4 高 (mm)

  COLUMNS: 3,         // 列数（A-one 30面は 3列×10行）
  ROWS: 10,           // 行数

  // Googleドキュメントの最小余白（約12.7mm = 0.5インチ）
  MIN_MARGIN: 12.7,   // 最小余白 (mm)

  // 印刷可能領域を計算
  PRINTABLE_WIDTH: 210 - (12.7 * 2),    // 210 - 25.4 = 184.6mm
  PRINTABLE_HEIGHT: 297 - (12.7 * 2),   // 297 - 25.4 = 271.6mm

  // カードサイズを印刷可能領域に合わせて計算
  CARD_WIDTH: (210 - (12.7 * 2)) / 3,   // 約61.5mm
  CARD_HEIGHT: (297 - (12.7 * 2)) / 10, // 約27.2mm

  // 最小余白を使用
  MARGIN_TOP: 12.7,
  MARGIN_LEFT: 12.7,

  // 表の罫線（切り取り線の目安）
  BORDER_PT: 0.5,
  BORDER_COLOR: '#cccccc',

  // セル内パディング（pt）
  CELL_PADDING_LEFT_PT: 3,
  CELL_PADDING_RIGHT_PT: 3,
};
const mm2pt = (mm) => mm * 2.83465;
// =====================================================================


/**
 * onOpen
 * シートを開いた時にメニューを追加する。
 * 使い方：シートで 10×3 の範囲を選択 → メニューから実行。
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('単語カード印刷')
    .addItem('選択範囲から作成', 'createWordCards')
    .addToUi();
}


/**
 * createWordCards
 * メイン処理：選択範囲（10×3）→ A-one レイアウトの Googleドキュメントを作成。
 * セルのリッチテキスト（書式含む）を各カード枠へコピーする。
 */
function createWordCards() {
  const ui = SpreadsheetApp.getUi();
  const sheet = SpreadsheetApp.getActiveSheet();
  const range = sheet.getActiveRange();

  // 1) 範囲チェック
  if (!range) {
    return ui.alert('エラー', '先にセル範囲を選択してください。', ui.ButtonSet.OK);
  }
  const rows = range.getNumRows();
  const cols = range.getNumColumns();
  if (rows !== CONFIG.ROWS || cols !== CONFIG.COLUMNS) {
    return ui.alert(
      '範囲選択エラー',
      `${CONFIG.ROWS}行 × ${CONFIG.COLUMNS}列 を選んでください。\n（現在: ${rows}行 × ${cols}列）`,
      ui.ButtonSet.OK
    );
  }

  // 2) 範囲のリッチテキストと配置情報を取得
  const richTextGrid = range.getRichTextValues(); // RichTextValue[][]
  const alignmentGrid = range.getHorizontalAlignments(); // 配置情報を取得

  try {
    // 3) A-one 用ページ設定の空Docを用意
    const doc = createDocumentShell_(); // Document
    const body = doc.getBody();

    // 4) A-one の表（枠）を作成（ここでサイズと罫線のみ設定）
    const table = body.appendTable();
    table.setAttributes({
      [DocumentApp.Attribute.BORDER_WIDTH]: CONFIG.BORDER_PT,
      [DocumentApp.Attribute.BORDER_COLOR]: CONFIG.BORDER_COLOR,
    });

    // 5) 各セルへ“書式を保ったまま”流し込み
    for (let r = 0; r < CONFIG.ROWS; r++) {
      const tr = table.appendTableRow();
      for (let c = 0; c < CONFIG.COLUMNS; c++) {
        const tc = tr.appendTableCell();

        // セルの見た目（サイズ・内側余白・縦位置）だけ設定。段落整形はしない
        tc.setAttributes({
          [DocumentApp.Attribute.WIDTH]:  mm2pt(CONFIG.CARD_WIDTH),
          [DocumentApp.Attribute.HEIGHT]: mm2pt(CONFIG.CARD_HEIGHT),
          [DocumentApp.Attribute.PADDING_LEFT]:  CONFIG.CELL_PADDING_LEFT_PT,
          [DocumentApp.Attribute.PADDING_RIGHT]: CONFIG.CELL_PADDING_RIGHT_PT,
          [DocumentApp.Attribute.VERTICAL_ALIGNMENT]: DocumentApp.VerticalAlignment.TOP,
        });

        // シートの RichText と配置を Docs セルに忠実コピー（堅牢版）
        copyRichTextToDocCell_(richTextGrid[r][c], tc, alignmentGrid[r][c]);
      }
    }

    // 6) 保存してURL表示
    doc.saveAndClose();
    const url = doc.getUrl();
    ui.showModalDialog(
      HtmlService.createHtmlOutput(
        `<p>単語カードを作成しました。<br><a href="${url}" target="_blank">ドキュメントを開く</a></p>`
      ).setWidth(360).setHeight(120),
      '生成完了'
    );

  } catch (err) {
    ui.alert('エラー', String(err && err.stack ? err.stack : err), ui.ButtonSet.OK);
  }
}


/**
 * createDocumentShell_
 * 新規 Googleドキュメントを作り、ページサイズ・余白を A-one 用に設定。
 * 本文は触らない（空段落を削除しない）。
 */
function createDocumentShell_() {
  const name = `単語カード_${new Date().toLocaleString('ja-JP')}`;
  const doc = DocumentApp.create(name);
  const body = doc.getBody();

  body.setPageWidth(mm2pt(CONFIG.PAGE_WIDTH));
  body.setPageHeight(mm2pt(CONFIG.PAGE_HEIGHT));
  body.setMarginTop(mm2pt(CONFIG.MARGIN_TOP));
  body.setMarginBottom(mm2pt(CONFIG.MARGIN_TOP));
  body.setMarginLeft(mm2pt(CONFIG.MARGIN_LEFT));
  body.setMarginRight(mm2pt(CONFIG.MARGIN_LEFT));

  return doc;
}


/**
 * copyRichTextToDocCell_
 * Sheets の RichTextValue（1セル分）を Docs の TableCell に可能な限り忠実にコピー（堅牢版）
 * - 書式ラン（getRuns）の start/end を「排他的 end」で正規化し、範囲外はクランプ
 * - 太字/斜体/下線/取消線/色/サイズ/フォントを反映
 * - リンクは RichTextValue.getLinkUrl(start, endExclusive) または全体 getLinkUrl() を使用
 * - 配置情報（左寄せ/中央寄せ/右寄せ）も反映する
 */
function copyRichTextToDocCell_(cellRich, tableCell, alignment) {
  // Docs 側セルに“空段落”を作り、編集対象を取得
  const paragraph = tableCell.appendParagraph('');
  const ed = paragraph.editAsText();

  if (!cellRich) return;                 // 値が無い
  const text = cellRich.getText() || ''; // 生文字
  if (text.length === 0) return;         // 空文字
  const L = text.length;

  const runs = cellRich.getRuns();       // 書式ラン配列（null/空あり）

  // 範囲を [0, L] にクランプ。end は排他的で統一
  const clampRange = (s, e) => {
    let start = Math.max(0, Math.min(L, (s|0)));
    let endEx = Math.max(0, Math.min(L, (e|0)));
    if (endEx <= start) return null;
    return { start, endEx };
  };

  if (runs && runs.length) {
    runs.forEach(run => {
      // run の end が包含/非包含で揺れるため、+1 してからクランプして安全化
      const sRaw = run.getStartIndex();
      const eRaw = run.getEndIndex() + 1;
      const rng = clampRange(sRaw, eRaw);
      if (!rng) return; // 空レンジはスキップ

      const seg = text.substring(rng.start, rng.endEx); // [start, endEx)
      const st  = run.getTextStyle();                   // ランのスタイル

      // 追加先の Docs 側文字位置
      const from = ed.getText().length;
      ed.appendText(seg);
      const to = from + seg.length - 1;                 // 包含終端

      // ---- 文字装飾 ----
      if (st) {
        if (st.isBold())          ed.setBold(from, to, true);
        if (st.isItalic())        ed.setItalic(from, to, true);
        if (st.isUnderline())     ed.setUnderline(from, to, true);
        if (st.isStrikethrough()) ed.setStrikethrough(from, to, true);

        const size  = st.getFontSize();
        const color = st.getForegroundColor();
        const fam   = st.getFontFamily();
        if (size)  ed.setFontSize(from, to, size);
        if (color) ed.setForegroundColor(from, to, color);
        if (fam)   ed.setFontFamily(from, to, fam);
      }

      // ---- リンク ----（RichTextStyle では取得できない）
      const linkUrl = cellRich.getLinkUrl(rng.start, rng.endEx); // [start, endEx)
      if (linkUrl) ed.setLinkUrl(from, to, linkUrl);
    });

  } else {
    // ランが無い場合：全体で適用
    ed.appendText(text);
    const from = 0, to = text.length - 1;

    const st = cellRich.getTextStyle(); // 全体スタイル
    if (st) {
      if (st.isBold())          ed.setBold(from, to, true);
      if (st.isItalic())        ed.setItalic(from, to, true);
      if (st.isUnderline())     ed.setUnderline(from, to, true);
      if (st.isStrikethrough()) ed.setStrikethrough(from, to, true);

      const size  = st.getFontSize();
      const color = st.getForegroundColor();
      const fam   = st.getFontFamily();
      if (size)  ed.setFontSize(from, to, size);
      if (color) ed.setForegroundColor(from, to, color);
      if (fam)   ed.setFontFamily(from, to, fam);
    }

    // 全体に同一リンクが付いている場合のみ返る
    const allLink = cellRich.getLinkUrl();
    if (allLink) ed.setLinkUrl(from, to, allLink);
  }

  // 段落の配置を適用（中央寄せなど）
  if (alignment) {
    let docAlignment;
    switch (alignment) {
      case 'left':
        docAlignment = DocumentApp.HorizontalAlignment.LEFT;
        break;
      case 'center':
        docAlignment = DocumentApp.HorizontalAlignment.CENTER;
        break;
      case 'right':
        docAlignment = DocumentApp.HorizontalAlignment.RIGHT;
        break;
      default:
        docAlignment = DocumentApp.HorizontalAlignment.LEFT;
    }
    paragraph.setAlignment(docAlignment);
  }
}
